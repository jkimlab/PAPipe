<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>dolmove</TITLE>
<META NAME="description" CONTENT="dolmove">
<META NAME="keywords" CONTENT="dolmove">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>
<BODY BGCOLOR="#ccffff">
<DIV ALIGN=RIGHT>
version 3.696
</DIV>
<P>
<DIV ALIGN=CENTER>
<H1>Dolmove  -- Interactive Dollo and Polymorphism Parsimony</H1>
</DIV>
</PRE>
<P>
&#169; Copyright 1986-2014 by Joseph Felsenstein. All rights reserved.
License terms <a href="main.html#copyright">here</a>.
<P>
Dolmove is an interactive parsimony program which uses the Dollo and 
Polymorphism parsimony criteria.  It was inspired by Wayne Maddison and
David Maddison's marvellous program MacClade, which was written for
Macintosh computers.  Dolmove reads in a data set which is prepared in almost 
the same format as one for the Dollo and polymorhism parsimony program 
Dollop.  It allows the user to choose an initial tree, and displays this tree 
on the screen.  The user can look at different characters and the way their 
states are distributed on that tree, given the most parsimonious reconstruction 
of state changes for that particular tree.  The user then can specify how the 
tree is to be rearraranged, rerooted or written out to a file.  By looking at 
different rearrangements of the tree the user can manually search for the most 
parsimonious tree, and can get a feel for how different characters are affected 
by changes in the tree topology.  
<P>
This program is compatible with fewer computer systems than the other
programs in PHYLIP.  It can be adapted to PCDOS systems or to
any system whose screen or terminals emulate DEC VT100
terminals (such as Telnet programs for logging in to remote computers over a
TCP/IP network,
VT100-compatible windows in the X windowing system, and any
terminal compatible with ANSI standard terminals).
For any other screen types, there is a generic option which does
not make use of screen graphics characters to display the character
states.  This will be less effective, as the states will be less
easy to see when displayed. 
<P>
The input data file is set up almost identically to the input file for 
Dollop.
<P>
The user interaction starts with the program presenting a menu.  The
menu looks like this:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>

Interactive Dollo or polymorphism parsimony, version 3.69

Settings for this run:
  P                        Parsimony method?  Dollo
  A                    Use ancestral states?  No
  F                 Use factors information?  No
  W                          Sites weighted?  No
  T                 Use Threshold parsimony?  No, use ordinary parsimony
  A      Use ancestral states in input file?  No
  U Initial tree (arbitrary, user, specify)?  Arbitrary
  0      Graphics type (IBM PC, ANSI, none)?  ANSI
  L               Number of lines on screen?  24
  S                Width of terminal screen?  80


Are these settings correct? (type Y or the letter for one to change)
</PRE>
</TD></TR></TABLE>
<P>
The P (Parsimony Method) option is the one that toggles between polymorphism
parsimony and Dollo parsimony.  The program defaults to Dollo parsimony.
<P>
The T (Threshold), F (Factors), A (Ancestors), and 0 (Graphics type) options
are the usual
ones and are described in the main documentation page and in the
Discrete Characters Program documentation page.  
<P>
The F (Factors)
option is used to inform the program which
groups of characters are to be counted together in computing the number of
characters compatible with the tree.  Thus if three binary characters are all
factors of the same multistate character, the multistate character will
be counted as compatible with the tree only if all three factors are compatible
with it.
<P>
The X (miXed methods) option is not available in Dolmove.
<P>
The usual W (Weights) option is available in Dolmove.  It allows integer
weights up to 36, using the symbols 0-9 and A-Z.  Increased weight on a step
increases both the number of parsimony steps on the character and the
contribution it makes to the number of compatibilities.
<P>
The T (threshold) option allows a continuum of methods between
parsimony and compatibility.  Thresholds less than or equal to 0 do not
have any 
meaning and should not be used: they will result in a tree dependent only on
the input order of species and not at all on the data!
<P>
The U (initial tree) option allows the user to choose whether
the initial tree is to be arbitrary, interactively specified by the user, or
read from a tree file.  Typing U causes the program to change among the
three possibilities in turn.  I
would recommend that for a first run, you allow the tree to be set up
arbitrarily (the default), as the "specify" choice is difficult 
to use and the "user tree" choice requires that you have available a tree file
with the tree topology of the initial tree.
Its default name is <TT>intree</TT>.  The program will ask you for its name if
it looks for the input tree file and does not find one of this name.
If you wish to set up some
particular tree you can also do that by the rearrangement commands specified
below.
<P>
The S (Screen width) option allows the width in characters of the
display to be adjusted when more then 80 characters can be displayed on
the user's screen.
<P>
The L (screen Lines) option allows the user to change the height of the
screen (in lines of characters) that is assumed to be available on the
display.  This may be particularly helpful when displaying large trees
on terminals that have more than 24 lines per screen, or on workstation
or X-terminal screens that can emulate the ANSI terminals with more than
24 lines.
<P>
After the initial menu is displayed and the choices are made,
the program then sets up an initial tree and displays it.  Below it will be a 
one-line menu of possible commands, which looks like this:
<P>
<PRE>
NEXT? (Options: R # + - S . T U W O F C H ? X Q) (H or ? for Help)
</PRE>
<P>
If you type H or ? you will get a single screen showing a description of each 
of these commands in a few words.  Here are slightly more detailed 
descriptions:
<P>
<DL>
<DT>R <DD>("Rearrange").  This command asks for the number of a node which is to be 
removed from the tree.  It and everything to the right of it on the tree is to
be removed (by breaking the branch immediately below it).  The command also
asks for the number of a node below which that group is to be inserted.  If an 
impossible number is given, the program refuses to carry out the rearrangement 
and asks for a new command.  The rearranged tree is displayed: it will often 
have a different number of steps than the original.  If you wish to undo a 
rearrangement, use the Undo command, for which see below.
<P>
<DT># <DD>This command, and the +, - and S commands described below, determine
which character has its states displayed on the branches of
the trees.  The initial tree displayed by the program does not show
states of sites.  When # is typed, the program does not ask the user which 
character is to be shown but automatically shows the states of the next 
binary character that is not compatible with the tree (the next character that
does not
perfectly fit the current tree).  The search for this character "wraps around"
so that if it reaches the last character without finding one that is not
compatible with the tree, the search continues at the first character; if no
incompatible character is found the current character is shown, and if no
current character is shown then the first character is shown.  If the last
character has been reached, using + again causes the first 
character to be shown.  The display takes the form of
different symbols or textures on the branches of the tree.  The state of each
branch is actually the state of the node above it.  A key of the symbols or
shadings used for states 0, 1 and ? are shown next to the tree.  State ? means
that either state 0 or state 1 could exist at that point on the tree, and that
the user may want to consider the different possibilities, which are usually
apparent by inspection. 
<DT>+ <DD>This command is the same as # except that it goes forward one character,
showing the states of the next character.  If no character has been shown,
using + will 
cause the first character to be shown.  Once the last character has been 
reached, using + again will show the first character.
<P>
<DT>- <DD>This command is the same as + except that it goes backwards, showing the 
states of the previous character.  If no character has been shown, using - will 
cause the last character to be shown.  Once character number 1 has been 
reached, using - again will show the last character.
<P>
<DT>S <DD>("Show").  This command is the same as + and - except that it causes
the program to ask you for the number of a character.  That character is
the one whose states will be displayed.  If you give the character number as 0,
the program will go back to not showing the states of the characters.
<P>
<DT>. (dot) <DD>This command simply causes the current tree to be redisplayed.  It is of 
use when the tree has partly disappeared off of the top of the screen owing to 
too many responses to commands being printed out at the bottom of the screen.  
<P>
<DT>T <DD>("Try rearrangements").  This command asks for the name of a node.  The
part of the tree at and above that node is removed from the tree.  The program
tries to re-insert it in each possible location on the tree (this may take some
time, and the program reminds you to wait).  Then it prints out a summary.  For
each possible location the program prints out the number of the node to the 
right of the
place of insertion and the number of steps required in each case.  These are
divided into those that are better, tied, or worse than the current tree.  Once
this summary is printed out, the group that was removed is inserted into its
original position.  It is up to you to use the R command to actually carry out
any the arrangements that have been tried. 
<P>
<DT>U <DD>("Undo").  This command reverses the effect of the most recent 
rearrangement, outgroup re-rooting, or flipping of branches.  It returns to the 
previous tree topology.  It will be of great use when rearranging the tree and 
when a rearrangement proves worse than the preceding one -- it permits you to 
abandon the new one and return to the previous one without remembering its 
topology in detail.
<P>
<DT>W <DD>("Write").  This command writes out the current tree onto a tree output 
file.  If the file already has been written to by this run of Dolmove, it will
ask you whether you want to replace the contents of the file, add the tree to
the end of the file, or  not write out the tree to the file.  The tree
is written in the standard format used by PHYLIP (a subset of the 
Newick standard).  It is in the proper format to serve as the
User-Defined Tree for setting up the initial tree in a subsequent run of the
program.
<P>
<DT>O <DD>("Outgroup").  This asks for the number of a node which is to be the 
outgroup.  The tree will be redisplayed with that node 
as the left descendant of the bottom fork.  The number of 
steps required on the tree may change on re-rooting.  Note that it is possible
to use this to make a multi-species group the outgroup (i.e., you can give the
number of an interior node of the tree as the outgroup, and the program will
re-root the tree properly with that on the left of the bottom fork).
<P>
<DT>F <DD>("Flip").  This asks for a node number and then flips the two branches at 
that, so that the left-right order of branches at that node is
changed.  This does not actually change the tree topology (or the number of
steps on that tree) but it does change the appearance of the tree.
<P>
<DT>C <DD>("Clade").  When the data consist of more than 12 species (or more than
half the number of lines on the screen if this is not 24), it may be
difficult to display the tree on one screen.  In that case the tree
will be squeezed down to 
one line per species.  This is too small to see all the interior states of the 
tree.  The C command instructs the program to print out only that part of the 
tree (the "clade") from a certain node on up.  The program will prompt you for 
the number of this node.  Remember that thereafter you are not looking at the 
whole tree.  To go back to looking at the whole tree give the C command again 
and enter "0" for the node number when asked.  Most users will not want to use 
this option unless forced to.
<P>
<DT>H <DD>("Help").  Prints a one-screen summary of what the commands do, a few 
words for each command.
<P>
<DT>? <DD>("huh?").  A synonym for H.  Same as Help command.
<P>
<DT>X <DD>("Exit").  Exit from program.  If the current tree has not yet been saved 
into a file, the program will ask you whether it should be saved.
<P>
<DT>Q <DD>("Quit").  A synonym for X.  Same as the eXit command.
</DL>
<P>
<H2>OUTPUT</H2>
<P>
If the A option is used, then
the program will infer, for any character whose ancestral state is unknown
("?") whether the ancestral state 0 or 1 will give the fewest changes 
(according to the criterion in use).  If these are tied, then it may not be 
possible for the program to infer the state in the internal nodes, and many of 
these will be shown as "?".  If the A option is not used, then the program will 
assume 0 as the ancestral state.
<P>
When reconstructing the placement of forward 
changes and reversions under the Dollo method, keep in mind that each 
polymorphic state in the input data will require one "last minute"
reversion.  This is included in the counts.  Thus if we have both states 0 and
1 at a tip of the tree the program will assume that the lineage had state 1 up
to the last minute, and then state 0 arose in that population by reversion, 
without loss of state 1.  
<P>
When Dolmove calculates the number of characters
compatible with the tree, it will take the F option into
account and count the multistate characters as units, counting a character
as compatible with the tree only when all of the binary characters 
corresponding to it are compatible with the tree.
<P>
<H2>ADAPTING THE PROGRAM TO YOUR COMPUTER AND TO YOUR TERMINAL</H2>
<P>
As we have seen, the initial menu of the program allows you to choose
among three screen types (PCDOS, Ansi, and none).
If you want to avoid having to make this choice every time, you can change
some of the constants in the file <TT>phylip.h</TT> to have the terminal type
initialize itself in the proper way, and recompile.  We have tried to
have the default values be correct for PC, Macintosh, and Unix
screens.  If the setting is "none" (which is necessary on
Macintosh MacOS 9 screens), the special graphics
characters will not be used to indicate nucleotide states, but only letters
will be used for the four nucleotides.  This is less easy to look at.
<P>
The constants that need attention are ANSICRT and IBMCRT.
Currently these are both set to "false" on Macintosh MacOS 9 systems,
to "true" on MacOS X and on Unix/Linux
systems, and IBMCRT is set to "true" on Windows systems.  If your system
has an ANSI compatible terminal, you might want to find the
definition of ANSICRT in <TT>phylip.h</TT> and set it to "true", and
IBMCRT to "false".
<P>
<H2>MORE ABOUT THE PARSIMONY CRITERION</H2>
<P>
Dolmove uses as its numerical criterion the Dollo and
polymorphism parsimony methods.  The program defaults to carrying out Dollo
parsimony.  
<P>
The Dollo parsimony method was
first suggested in print by Le Quesne (1974) and was
first well-specified by Farris (1977).  The method is named after Louis
Dollo since he was one of the first to assert that in evolution it is
harder to gain a complex feature than to lose it.  The algorithm
explains the presence of the state 1 by allowing up to one forward
change 0-->1 and as many reversions 1-->0 as are necessary to explain
the pattern of states seen.  The program attempts to minimize the number
of 1-->0 reversions necessary.
<P>
The assumptions of this method are in effect:
<P>
<OL>
<LI>We know which state is the ancestral one (state 0).
<LI>The characters are evolving independently.
<LI>Different lineages evolve independently.
<LI>The probability of a forward change (0-->1) is small over the
evolutionary times involved.
<LI>The probability of a reversion (1-->0) is also small, but
still far larger than the probability of a forward change, so
that many reversions are easier to envisage than even one
extra forward change.
<LI>Retention of polymorphism for both states (0 and 1) is highly
improbable.
<LI>The lengths of the segments of the true tree are not so
unequal that two changes in a long segment are as probable as
one in a short segment.
</OL>
<P>
One problem can arise when using additive binary recoding to
represent a multistate character as a series of two-state characters.  Unlike
the Camin-Sokal, Wagner, and Polymorphism methods, the Dollo
method can reconstruct ancestral states which do not exist.  An example
is given in my 1979 paper.  It will be necessary to check the output to
make sure that this has not occurred.
<P>
The polymorphism parsimony method was first used by me, 
and the results published 
(without a clear
specification of the method) by Inger (1967).  The method was independently
published by Farris (1978a) and by me (1979).  The method
assumes that we can explain the pattern of states by no more than one
origination (0-->1) of state 1, followed by retention of polymorphism
along as many segments of the tree as are necessary, followed by loss of
state 0 or of state 1 where necessary.  The program tries to minimize
the total number of polymorphic characters, where each polymorphism is
counted once for each segment of the tree in which it is retained.
<P>
The assumptions of the polymorphism parsimony method are in effect:
<P>
<OL>
<LI>The ancestral state (state 0) is known in each character.
<LI>The characters are evolving independently of each other.
<LI>Different lineages are evolving independently.
<LI>Forward change (0-->1) is highly improbable over the length of
time involved in the evolution of the group.
<LI>Retention of polymorphism is also improbable, but far more
probable that forward change, so that we can more easily
envisage much polymorhism than even one additional forward
change.
<LI>Once state 1 is reached, reoccurrence of state 0 is very
improbable, much less probable than multiple retentions of
polymorphism.
<LI>The lengths of segments in the true tree are not so unequal
that we can more easily envisage retention events occurring in
both of two long segments than one retention in a short
segment.
</OL>
<P>
That these are the assumptions of parsimony methods has been documented
in a series of papers of mine: (1973a, 1978b, 1979, 1981b,
1983b, 1988b).  For an opposing view arguing that the parsimony methods
make no substantive 
assumptions such as these, see the papers by Farris (1983) and Sober (1983a, 
1983b), but also read the exchange between Felsenstein and Sober (1986).  
<P>
Below is a test data set, but we cannot show the
output it generates because of the interactive nature of the program.
<P>
<HR>
<P>
<H3>TEST DATA SET</H3>
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
     5    6
Alpha     110110
Beta      110000
Gamma     100110
Delta     001001
Epsilon   001110
</PRE>
</TD></TR></TABLE>
</BODY>
</HTML>
